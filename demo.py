from typing import List, Dict
import os
import json
import pprint
import argparse
import pickle


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--data_src', type=str, default='valid', choices=['test', 'valid'])
    parser.add_argument('--data_dir', type=str, default='data')
    parser.add_argument('--result_dir', type=str, default='result')

    return vars(parser.parse_args())


def get_data_path(data_dir: str, result_dir: str, test_valid: str) -> (str, str, str, str):
    data_path = os.path.join(data_dir, f'{test_valid}_data.jsonl')
    inference_path = os.path.join(result_dir, f'output_{test_valid}.txt')
    conversation_path = os.path.join(result_dir, f'conversation_{test_valid}.txt')
    convs_pretty_path = os.path.join(result_dir, f'conversation_{test_valid}_pretty.txt')
    return data_path, inference_path, conversation_path, convs_pretty_path


def print_conversation_log(convs: List[List[Dict[str, str]]], output_path: str) -> None:
    with open(output_path, 'w') as out:
        for conv in convs:
            out.write(f"{'='*40}Start{'='*40}\n")
            for utter in conv:
                speaker_type = list(utter.keys())[0]
                utterance = utter[speaker_type]
                if speaker_type == 'c':
                    for u in utterance:
                        out.write(u+'\n')
                elif speaker_type == 'r':
                    out.write(f"{'': <30} Human\n")
                    for u in utterance:
                        out.write(f"{'': <40}{u}\n")
                else:
                    out.write(f"{'': <30} Machine\n")
                    for u in utterance:
                        out.write(f"{'': <40}{u}\n")

            out.write(f"{'='*41}End{'='*41}\n")


def main():
    # prepare arguments
    opt = get_args()
    context_path, inference_path, conversation_path, convs_pretty_path = get_data_path(
        opt['data_dir'], opt['result_dir'], opt['data_src'])

    # load context data
    with open(context_path, 'r') as f_con:
        context_raw_data = [json.loads(context) for context in f_con.readlines()]

    # transform raw context data into useful data
    context_data = []
    movie_dict = {}
    for context in context_raw_data:
        messages_session = []
        msg_group = []
        speakerId = None

        for msg in context['messages']:
            # group msgs of the same speaker
            if speakerId != msg['senderWorkerId']:
                msg_group.append(('c', messages_session) if speakerId ==
                                 context['initiatorWorkerId'] else ('r', messages_session))

                # update speakerId
                speakerId = msg['senderWorkerId']
                # init new session
                messages_session = [msg['text']]
            else:
                messages_session.append(msg['text'])
        msg_group.append(('c', messages_session) if speakerId ==
                         context['initiatorWorkerId'] else ('r', messages_session))

        context_data.append({
            'client': context['initiatorWorkerId'],
            'respondent': context['respondentWorkerId'],
            'msgGroup': msg_group[1:],
            'conversationId': context['conversationId']
        })

        for key, val in context['movieMentions'].items():
            if not key in movie_dict:
                movie_dict[key] = val

    # save movie dictionary
    moive_path = os.path.join(opt['data_dir'], 'movie_id2name.pkl')
    with open(moive_path, 'wb') as movie_file:
        print(f'Save the mapping from movie id to its name: {moive_path}')
        pickle.dump(movie_dict, movie_file)

    # add response generated by the model
    conversations = []
    with open(inference_path, 'r') as f_inf:
        inference = [sen.strip() for sen in f_inf.readlines()]
        inf_idx = 0

        for context in context_data:
            conversation = []
            clientId = context['client']
            responsdentId = context['respondent']

            for idx, utter in enumerate(context['msgGroup']):
                if utter[0] == 'c':
                    conversation.append({'c': utter[1]})
                else:
                    assert inf_idx < len(
                        inference), f"ConversationId={context['conversationId']}, Inf_idx={inf_idx}"
                    conversation.append({'r': utter[1]})

                    if idx != 0:
                        conversation.append({'i': [inference[inf_idx]]})
                        inf_idx += 1

            conversations.append(conversation)

    # replace movie index by names
    for conversation in conversations:
        for sessions in conversation:
            for key in list(sessions.keys()):
                session = sessions[key]
                idx_at = None
                for i in range(len(session)):
                    while session[i].find('@') != -1:
                        idx_at = session[i].find('@')
                        if session[i][idx_at:].find(' ') != -1:
                            idx_end = session[i][idx_at:].find(' ') + idx_at
                        elif session[i][idx_at:].find('.') != -1:
                            idx_end = session[i][idx_at:].find('.') + idx_at
                        elif session[i][idx_at:].find('?') != -1:
                            idx_end = session[i][idx_at:].find('?') + idx_at
                        else:
                            idx_end = len(session[i])
                        movie_id = session[i][idx_at+1:idx_end]
                        if movie_id in movie_dict:
                            session[i] = session[i][:idx_at] + \
                                f"=={movie_dict[movie_id]}==" + session[i][idx_end:]
                        else:
                            session[i] = session[i][:idx_at] + \
                                f"=={movie_id}==" + session[i][idx_end:]

                if key == 'i' and idx_at is not None:
                    sessions['i*'] = session
                    del sessions[key]

    # write to conversation_path
    with open(conversation_path, 'w') as f_out:
        pp = pprint.PrettyPrinter(indent=4, width=200, stream=f_out)
        pp.pprint(conversations)

    print_conversation_log(conversations, output_path=convs_pretty_path)


if __name__ == '__main__':
    main()
